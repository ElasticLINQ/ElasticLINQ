<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core"#>
<#@ assembly name="Microsoft.CSharp"#>
<#@ assembly name="$(SolutionDir)\\packages\\Newtonsoft.Json.6.0.5\\lib\\net40\\Newtonsoft.Json.dll" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Dynamic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Newtonsoft.Json" #>
<#@ import namespace="Newtonsoft.Json.Linq" #>
<#@ import namespace="Newtonsoft.Json.Converters" #>
<#
	var xxx_apis = new string[]
    {
		File.ReadAllText(this.Host.ResolvePath("Specs/document_apis.json")),
		File.ReadAllText(this.Host.ResolvePath("Specs/cluster_apis.json")),
    };

	IEnumerable<dynamic> apis = xxx_apis.Select(x => (dynamic) JsonConvert.DeserializeObject(x)).SelectMany(x => (IEnumerable<dynamic>) x.Properties());
#>
namespace ElasticApi.Requests
{
	using System;
	using System.Collections.Generic;
	using Attributes;

<#
	foreach(var property in apis)
    {
#>
    /// <summary>
    /// <para>Request for <#=property.Name#> api</para>
	/// <para>Path: <#=property.Value.url.path#></para>
	/// <para>Methods: <#=string.Join(", ", (property.Value.methods as IEnumerable<object>))#></para>
	/// <para>Paths: <#=string.Join(", ", (property.Value.url.paths as IEnumerable<object>))#></para>
    /// </summary>
	public class <#=PascalCase(property.Name)#>Request
	{
<#
		foreach(var part in property.Value.url.parts)
		{
			bool required = part.Value.required != null ? part.Value.required.Value : false;
			string type = part.Value.type != null ? part.Value.type.Value : "string";
			string[] parts = (property.Value.url.path.Value as string).Split('/');
#>
        /// <summary>
        /// <para><#=part.Value.description#></para>
		/// <para>Type: url</para>
        /// <para>Required: <#=required#></para>
        /// </summary>
		public <#=CSharpType(type, required)#> <#=PascalCase(part.Name)#> { get; set; }
<#
        }
#>
<#
		foreach(var part in property.Value.url.@params)
		{
			string type = part.Value.type != null ? part.Value.type.Value : "string";
#>
        /// <summary>
        /// <para><#=part.Value.description#></para>
		/// <para>Type: parameter</para>
        /// <para>Name: <#=part.Name#></para>
        /// </summary>
		public <#=CSharpType(type, false)#> <#=PascalCase(part.Name)#> { get; set; }
<#
        }
#>
<#
		if (property.Value.body != null)
		{
#>
        /// <summary>
        /// <para><#=property.Value.body.description#></para>
        /// </summary>
		[ApiBody]
		public object Body { get; set; }
<#
        }
#>
	}
<#
    }
#>
}

namespace ElasticApi.Responses
{
	using System;
	using System.Collections.Generic;
	using Newtonsoft.Json;

<#
	foreach(var property in apis)
    {
#>
    /// <summary>
    /// <para>Response for <#=property.Name#> api</para>
    /// </summary>
	public class <#=PascalCase(property.Name)#>Response
	{
<#
		foreach(var part in property.Value.response)
		{
			string type = part.Value.type != null ? part.Value.type.Value : "string";
#>
        /// <summary>
        /// <para><#=part.Value.description#></para>
		/// <para>Type: parameter</para>
        /// <para>Name: <#=part.Name#></para>
        /// </summary>
		[JsonProperty("<#=part.Name#>")]
		public <#=CSharpType(type, false)#> <#=PascalCase(part.Name)#> { get; set; }
<#
        }
#>
	}
<#
    }
#>
}

namespace ElasticApi
{
    using System.Collections.Generic;
    using System.Threading.Tasks;
    using Requests;
    using Responses;

	public static class Elastic
	{
<#
	foreach(var property in apis)
    {
		var api = PascalCase(property.Name);
		var method = (property.Value.methods as IEnumerable<object>).First().ToString().ToLower();
#>
		/// <summary>
		/// <#=property.Value.documentation#>
		/// </summary>
		/// <param name="request">request input</param>
		public static <#=api#>Response <#=api#>(IConnection connection, <#=api#>Request request)
		{
			IEnumerable<string> path = Routing.GetPath(request);
			IDictionary<string, object> parameters = Routing.GetParameters(request);
<#
			if (method == "post" || method == "put")
			{
#>
			object body = RequestHelper.GetBody(request);

			return connection.<#=PascalCase(method)#><<#=api#>Response>(path, parameters, body);
<#
			}
			else
            {
#>
			return connection.<#=PascalCase(method)#><<#=api#>Response>(path, parameters);
<#
			}
#>
		}
		/// <summary>
		/// <#=property.Value.documentation#>
		/// </summary>
		/// <param name="request">request input</param>
		public static Task<<#=api#>Response> <#=api#>Async(IConnection connection, <#=api#>Request request)
		{
			//	TODO : async version
			return default(Task<<#=api#>Response>);
		}
<#
    }
#>
	}
}

namespace ElasticApi
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Requests;

	public static class Routing
	{
<#
	foreach(var property in apis)
    {
		var api = PascalCase(property.Name);
#>

		private static readonly List<Func<<#=api#>Request, string>[]> <#=api#>Paths = new List<Func<<#=api#>Request, string>[]>
		{
<#
		foreach(var path in property.Value.url.paths)
		{
#>
			new Func<<#=api#>Request, string>[]
			{
<#
			var segments = path.Value.Split(new [] { '/' }, StringSplitOptions.RemoveEmptyEntries);

			foreach(var segment in segments)
			{
#>
<#
				if (segment.Contains("}") == true)
                {
#>
				x => RequestHelper.Segment(x.<#=PascalCase(segment.Substring(1, segment.Length - 2))#>),
<#
                }
				else
                {
#>
				x => "<#=segment#>",
<#
                }
#>
<#
            }
#>
			},
<#
        }
#>
		};
		
		public static IEnumerable<string> GetPath(<#=api#>Request request)
		{
			var path = <#=api#>Paths.First();

			return path.Select(x => x(request));
		}

		public static IDictionary<string, object> GetParameters(<#=api#>Request request)
		{
			var parameters = new Dictionary<string, object>();
<#
		foreach(var param in property.Value.url.@params)
		{
#>
			{
				object value = RequestHelper.Param(request.<#=PascalCase(param.Name)#>);

				if (value != null)
				{
					parameters.Add("<#=param.Name#>", value);
				}
			}
<#
		}
#>
			RequestHelper.AddCommonParameters(parameters);

			return parameters;
		}
<#
    }
#>
	}
}
<#+
internal class TypeMapping
{
	public readonly string Type;
	public readonly string NullableType;

	public TypeMapping(string type, string nullableType)
    {
		this.Type = type;
		this.NullableType = nullableType;
    }
}

IDictionary<string, TypeMapping> mappings = new Dictionary<string, TypeMapping>
{
    { "boolean", new TypeMapping("bool", "Nullable<bool>") },
    { "number", new TypeMapping("long", "Nullable<long>") },
    { "string", new TypeMapping("string", "string") },
    { "enum", new TypeMapping("string", "string") },
    { "list", new TypeMapping("IEnumerable<string>", "IEnumerable<string>") },
    { "time", new TypeMapping("TimeSpan", "Nullable<TimeSpan>") },
    { "duration", new TypeMapping("TimeSpan", "Nullable<TimeSpan>") },
};

public string CSharpType(string type, bool required)
{
	return required == false ? mappings[type].NullableType :  mappings[type].Type;
}
#>
<#+
public static string PascalCase(string raw)
{
	string temp = string.Empty;

	foreach(var c in raw)
	{
		if (char.IsUpper(c))
		{
			temp += "_";
		}

		temp += c;
	}

	return System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(temp).Replace("_", "");
}
#>